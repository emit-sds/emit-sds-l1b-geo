#! /usr/bin/env python
#
# This runs the L1B Geo process.
import geocal
import emit
import logging
import os
import re
import shutil
import h5py
import traceback
from multiprocessing import Pool
import numpy as np

# Get version information, in the top directory
import sys
sys.path.append(os.path.dirname(os.path.abspath(sys.path[0])))
from emit_version import *

version = "0.01"
usage='''Usage:
  l1b_geo_process [options] <l1a_raw_att> <start_time> <prod_dir>
  l1b_geo_process -h | --help
  l1b_geo_process -v | --version

This runs the L1B Geo process. 

Right now we take an ecostress L1A_RAW_ATT (as a placeholder for an EMIT
orbit file) and a start time (in CCSDS format, e.g "2019-02-27T10:12:22.0000Z").
We don't take radiance data now, but of course we will need that later as we
flesh out this program.

Options:
  -h --help         
       Print this message

  --debug
       Turn debugging information on
       
  --log-file=f
       Give a path for the logs to be written to. This goes to both the screen
       an the log file, compare with --log-file-only

  --log-file-only=f
       Write logs only to the log file, not also to the screen.

  --no-color
       Don't colorize output. Only applies to the screen, we never put
       color into log files.

  --number-cpu=d
       Number of CPUs to use when processing. Ignored if we are using a 
       run_config file, this is instead passed through the config file.
       [default: 10]

  --quiet
       Don't print any messages, just return an overall status code.

  --verbose
       Give more verbose messages. Synonym for debug.

  -v --version      
       Print program version
'''

args = geocal.docopt_simple(usage, version=version)

# Can use this to wait a short time so we can attach strace to this
# process, useful to find all the files that we are accessing.
if(False):
    print("Waiting a short time")
    import time
    time.sleep(20)

logger = logging.getLogger('l1b_geo_process')
fh = None
if(args.log_file_only or args.log_file):
    fh = logging.FileHandler(args.log_file_only or args.log_file)
    fh.setFormatter(pynitf.DifferenceFormatter(add_color = False))
    fh.setLevel(logging.INFO)
    logger.addHandler(fh)
lformat = emit.L1bGeoLogFormatter(add_color = not args.no_color)
if(not args.log_file_only):    
    h = logging.StreamHandler()
    h.setFormatter(lformat)
    logger.addHandler(h)
if(args.debug):
    if(h):
        h.setLevel(logging.DEBUG)
    logger.setLevel(logging.DEBUG)
elif(args.verbose):
    if(h):
        h.setLevel(logging.DEBUG)
    logger.setLevel(logging.INFO)
elif(args.quiet):
    if(h):
        h.setLevel(1000)
    logger.setLevel(1000)
else:    
    if(h):
        h.setLevel(logging.INFO)
    logger.setLevel(logging.INFO)

try:
    logger.info("Starting l1b_geo %s processing", pge_version["l1b_geo"])
    os.makedirs(args.prod_dir, exist_ok=True)
    igc = emit.emit_igc(args.l1a_raw_att, geocal.Time.parse_time(args.start_time))
    g = emit.L1bGeoGenerate(igc, args.prod_dir)
    loc_fname = g.emit_file_name("l1b_loc")
    obs_fname = g.emit_file_name("l1b_obs")
    glt_fname = g.emit_file_name("l1b_glt")
    att_fname = g.emit_file_name("l1b_att", ext=".nc")
    quicklook_fname = g.emit_file_name("l1b_rdn", ext=".png")
    kmz_fname = g.emit_file_name("l1b_rdn", ext=".kmz")
    qa_fname = g.emit_file_name("l1b_geoqa", ext=".nc")
    g.generate_loc(loc_fname)
    g.generate_obs(obs_fname, loc_fname)
    g.generate_glt(glt_fname)
    # TODO Need to add a geographic version of GLT also. Need to find the 
    # file name and actually implement
    g.generate_att(att_fname)
    g.generate_quicklook(quicklook_fname)
    g.generate_kmz(kmz_fname)
    g.generate_qa(qa_fname)
    logger.info("Done with l1b_geo processing")
except Exception as e:
    raise
    logger.exception(e, stack_info=True)
    logger.fatal("L1b_geo processing failed")
    sys.exit(1)

